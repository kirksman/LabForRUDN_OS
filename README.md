**РОССИЙСКИЙ УНИВЕРСИТЕТ ДРУЖБЫ НАРОДОВ**

**Факультет физико-математических и естественных наук**

**Кафедра прикладной информатики и теории вероятностей**

**ОТЧЕТ**

**по лабораторной работе № 15**

_дисциплина: Операционные системы_

Преподаватель: Велиева Татьяна Рефатовна

Студент: Муратов Кирилл Александрович

Группа: НПМбв-01-19

**МОСКВА**

2023 г.

**ЗАДАЧА:**

Программирование в командном процессоре ОС UNIX. Именованные каналы

**ЦЕЛЬ:**

Приобретение практических навыков работы с именованными каналами.

**ИССЛЕДУЕМАЯ ОПЕРАЦИОННАЯ СИСТЕМА:**

1. CentOS

**ПО:**

1. Windows 10
2. Диспетчер Hyper-v от Microsoft
3. MobaXTern


**ТЕРМИНЫ:**

**SSH** (**secure shell** ) - сетевой протокол прикладного уровня, позволяющий производить удалённое управление операционной системой и туннелирование TCP-соединений.

**OS\ОС** – операционная система

**Linux** – семейство UNIX-подобных ОС на базе ядра Linux

**Начало работы**

Изучите приведённые в тексте программы server.c и client.c. Взяв данные примеры за образец, напишите аналогичные программы, внеся следующие изменения: 1. Работает не 1 клиент, а несколько (например, два). 2. Клиенты передают текущее время с некоторой периодичностью (например, раз в пять секунд). Используйте функцию sleep() для приостановки работы клиента. 3. Сервер работает не бесконечно, а прекращает работу через некоторое время (например, 30 сек). Используйте функцию clock() для определения времени работы сервера. Что будет в случае, если сервер завершит работу, не закрыв канал?

Для реализации изменений в программе server.c и client.c, позволяющих нескольким клиентам передавать текущее время с периодичностью и устанавливать ограничение по времени работы сервера.

Вот пример модифицированной программы клиента (client_modified.c):

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/ipc.h>
#include <sys/msg.h>

#define MESSAGE_SIZE 128

struct msg_buffer {
long msg_type;
char msg_text[MESSAGE_SIZE];
};

int main() {
key_t key;
int msg_id;
struct msg_buffer message;
time_t t;

    // Получение ключа
    if ((key = ftok("progfile", 65)) == -1) {
        perror("ftok");
        exit(1);
    }

    // Создание очереди сообщений
    if ((msg_id = msgget(key, 0666 | IPC_CREAT)) == -1) {
        perror("msgget");
        exit(1);
    }

    while (1) {
        // Генерация текущего времени
        time(&t);
        sprintf(message.msg_text, "Client: Current time is %s", ctime(&t));
        message.msg_type = 1;

        // Отправка сообщения
        if (msgsnd(msg_id, &message, sizeof(message), 0) == -1) {
            perror("msgsnd");
            exit(1);
        }

        sleep(5); // Периодичность передачи времени (5 секунд)
    }

    return 0;
}

В этой программе клиенту была добавлена возможность периодической отправки текущего времени в очередь сообщений.
Теперь перейдем к модификации серверной программы (server_modified.c):
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>
#include <sys/types.h>
#include <sys/ipc.h>
#include <sys/msg.h>
#include <signal.h>

#define MESSAGE_SIZE 128
#define MAX_CLIENTS 2 // Количество клиентов
#define SERVER_RUNTIME 30 // Время работы сервера в секундах

struct msg_buffer {
long msg_type;
char msg_text[MESSAGE_SIZE];
};

int main() {
key_t key;
int msg_id;
struct msg_buffer message;
time_t start_time, current_time;

    // Получение ключа
    if ((key = ftok("progfile", 65)) == -1) {
        perror("ftok");
        exit(1);
    }

    // Создание очереди сообщений
    if ((msg_id = msgget(key, 0666 | IPC_CREAT)) == -1) {
        perror("msgget");
        exit(1);
    }

    // Задаем время начала работы сервера
    time(&start_time);

    // Основной цикл сервера
    while (1) {
        // Проверка времени работы сервера
        time(&current_time);
        if (current_time - start_time >= SERVER_RUNTIME) {
            printf("Server: Server runtime limit reached. Exiting.\n");
            break;
        }

        // Получение сообщения
        if (msgrcv(msg_id, &message, sizeof(message), 1, 0) == -1) {
            perror("msgrcv");
            exit(1);
        }

        printf("%s", message.msg_text);
    }

    // Удаление очереди сообщений
    if (msgctl(msg_id, IPC_RMID, NULL) == -1) {
        perror("msgctl");
        exit(1);
    }

    return 0;
}

В этой модифицированной программе сервера было добавлено ограничение по времени работы (SERVER_RUNTIME) в 30 секунд. После истечения этого времени сервер завершит выполнение. Также программа сервера будет принимать сообщения от двух клиентов (MAX_CLIENTS), что было указано в вашем требовании.
Что произойдет, если сервер завершит работу, не закрыв канал (очередь сообщений), то в этом случае канал (очередь) будет оставаться открытым
и доступным для других процессов.
Однако, после завершения сервера,больше не будет возможности отправлять сообщения в эту очередь (поскольку сервер больше не будет прослушивать ее).

**Контрольные вопросы**
**1. В чем ключевое отличие именованных каналов от неименованных?**
Именованные каналы отличаются от неименованных наличием идентификатора канала, который представлен как специальный файл (соответственно имя именованного канала — это имя файла). Поскольку файл находится на локальной файловой системе, данное IPC используется внутри одной системы.
**2. Возможно ли создание неименованного канала из командной строки?**
**3. Возможно ли создание именованного канала из командной строки?**
**4. Опишите функцию языка С, создающую неименованный канал.**
**5. Опишите функцию языка С, создающую именованный канал.**
**6. Что будет в случае прочтения из fifo меньшего числа байтов, чем находится вканале? Большего числа байтов?**
**7. Аналогично, что будет в случае записи в fifo меньшего числа байтов, чем позволяет буфер? Большего числа байтов?**
**8. Могут ли два и более процессов читать или записывать в канал?**
**9. Опишите функцию write (тип возвращаемого значения, аргументы и логику работы). Что означает 1 (единица) в вызове этой функции в программе server.c (строка 42)?**
**10. Опишите функцию strerror.**